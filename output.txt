# password_manager/core/auth.py

from abc import ABC, abstractmethod
from pathlib import Path
import hashlib
import os
import base64
import logging

class AuthenticationService(ABC):
    """Abstract base class for authentication services."""
    
    @abstractmethod
    def authenticate(self, password: str) -> bool:
        """Authenticate using the given password."""
        pass
    
    @abstractmethod
    def set_master_password(self, password: str) -> None:
        """Set or update the master password."""
        pass

class HashBasedAuth(AuthenticationService):
    """Simple hash-based authentication implementation."""
    
    def __init__(self, master_password_file: Path):
        self.master_password_file = master_password_file
        self.salt_file = master_password_file.parent / 'salt'
        self._master_key = None
        self._salt = self._load_or_create_salt()
    
    def get_master_key(self) -> bytes:
        if self._master_key is None:
            raise ValueError("No master key available. Please authenticate first.")
        return self._master_key
    
    def _load_or_create_salt(self) -> bytes:
        """Load the stored salt from file (stripping whitespace) or create a new one."""
        if self.salt_file.exists():
            return base64.b64decode(self.salt_file.read_text().strip())
        salt = os.urandom(16)
        self.salt_file.parent.mkdir(parents=True, exist_ok=True)
        self.salt_file.write_text(base64.b64encode(salt).decode())
        return salt

    @property
    def salt(self) -> bytes:
        """Expose the persisted salt."""
        return self._salt

    def _hash_password(self, password: str) -> bytes:
        return hashlib.pbkdf2_hmac(
            'sha256',
            password.encode(),
            self._salt,
            100000,
            dklen=32
        )
    
    def authenticate(self, password: str) -> bool:
        if not self.master_password_file.exists():
            return False
        stored_hash = self.master_password_file.read_text().strip()
        password_hash = self._hash_password(password)
        logging.debug(f"Stored hash: {stored_hash}, Computed hash: {base64.b64encode(password_hash).decode()}")
        logging.debug(f"Using salt: {base64.b64encode(self._salt).decode()}")
        if base64.b64encode(password_hash).decode() == stored_hash:
            self._master_key = password_hash
            logging.debug(f"Authentication successful, master key: {self._master_key.hex()}")
            return True
        return False
    
    def set_master_password(self, password: str) -> None:
        password_hash = self._hash_password(password)
        self._master_key = password_hash
        self.master_password_file.parent.mkdir(parents=True, exist_ok=True)
        self.master_password_file.write_text(base64.b64encode(password_hash).decode())
# password_manager/core/encryption.py

import os
import base64
import logging
from typing import Optional
from abc import ABC, abstractmethod
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.exceptions import InvalidTag

class EncryptionService(ABC):
    """Abstract base class for encryption services."""
    
    @abstractmethod
    def encrypt(self, data: bytes) -> bytes:
        """Encrypt the given data."""
        pass
    
    @abstractmethod
    def decrypt(self, encrypted_data: bytes) -> bytes:
        """Decrypt the given data."""
        pass

class AES256Encryption(EncryptionService):
    """AES-256 encryption implementation with proper key derivation."""
    
    def __init__(self, master_key: bytes, salt: Optional[bytes] = None):
        """
        Initialize with the master key and a provided salt.
        If no salt is given, a new one is generated.
        """
        self._master_key = master_key
        self._salt = salt if salt is not None else os.urandom(16)
        self._key = self._derive_key()
        logging.debug(f"Initialized AES256Encryption with key: {self._key.hex()} and salt: {self._salt.hex()}")
    
    def _derive_key(self) -> bytes:
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=self._salt,
            iterations=100000,
        )
        return kdf.derive(self._master_key)
    
    def encrypt(self, data: bytes) -> bytes:
        iv = os.urandom(12)  # 96-bit IV for GCM
        cipher = Cipher(
            algorithms.AES(self._key),
            modes.GCM(iv),
        )
        encryptor = cipher.encryptor()
        ciphertext = encryptor.update(data) + encryptor.finalize()
        logging.debug(f"Encrypted data with IV: {iv.hex()}, Tag: {encryptor.tag.hex()}, Ciphertext: {ciphertext.hex()}")
        # Combine IV, tag, and ciphertext; then base64-encode
        return base64.b64encode(iv + encryptor.tag + ciphertext)
    
    def decrypt(self, encrypted_data: bytes) -> bytes:
        raw_data = base64.b64decode(encrypted_data)
        iv = raw_data[:12]
        tag = raw_data[12:28]
        ciphertext = raw_data[28:]
        logging.debug(f"Decrypting data with IV: {iv.hex()}, Tag: {tag.hex()}, Ciphertext length: {len(ciphertext)}")
        logging.debug(f"Using key: {self._key.hex()}")
        cipher = Cipher(
            algorithms.AES(self._key),
            modes.GCM(iv, tag),
        )
        decryptor = cipher.decryptor()
        try:
            decrypted_data = decryptor.update(ciphertext) + decryptor.finalize()
            logging.debug(f"Decryption successful, plaintext: {decrypted_data.decode(errors='ignore')}")
            return decrypted_data
        except InvalidTag as e:
            logging.error("Decryption failed due to invalid tag", exc_info=e)
            raise

    @property
    def key(self) -> bytes:
        return self._master_key
    
    @property
    def salt(self) -> bytes:
        return self._salt
from typing import Dict, List, Optional
from password_manager.core.password import Password
from password_manager.core.encryption import EncryptionService
import json
import os
from pathlib import Path
import base64
from datetime import datetime

class PasswordVault:
    """Manages the storage and retrieval of passwords."""
    
    def __init__(self, encryption_service: EncryptionService, storage_path: Path):
        self.encryption = encryption_service
        self.storage_path = storage_path
        self.storage_path.mkdir(parents=True, exist_ok=True)
        self._passwords: Dict[str, Password] = {}
        self._load_passwords()
    
    def add_password(self, domain: str, username: str, password: str, description: Optional[str] = None) -> Password:
        """Add a new password to the vault."""
        encrypted_password = self.encryption.encrypt(password.encode())
        password_entry = Password.create(
            domain=domain,
            username=username,
            encrypted_password=encrypted_password,
            description=description
        )
        self._passwords[password_entry.id] = password_entry
        self._save_passwords()
        return password_entry
    
    def get_password(self, password_id: str) -> Optional[Password]:
        """Retrieve a password by its ID."""
        return self._passwords.get(password_id)
    
    def get_decrypted_password(self, password_id: str) -> Optional[str]:
        """Get the decrypted password string for a given password ID."""
        password_entry = self.get_password(password_id)
        if password_entry:
            decrypted = self.encryption.decrypt(password_entry.encrypted_password)
            return decrypted.decode()
        return None
    
    def list_passwords(self) -> List[Password]:
        """List all passwords in the vault."""
        return list(self._passwords.values())
    
    def delete_password(self, password_id: str) -> bool:
        """Delete a password from the vault."""
        if password_id in self._passwords:
            del self._passwords[password_id]
            self._save_passwords()
            return True
        return False
    
    def _save_passwords(self):
        """Save passwords to storage."""
        passwords_data = {
            id_: {
                'id': p.id,
                'domain': p.domain,
                'username': p.username,
                'encrypted_password': base64.b64encode(p.encrypted_password).decode(),
                'description': p.description,
                'created_at': p.created_at.isoformat(),
                'modified_at': p.modified_at.isoformat()
            }
            for id_, p in self._passwords.items()
        }
        
        with open(self.storage_path / 'passwords.json', 'w') as f:
            json.dump(passwords_data, f, indent=2)
    
    def _load_passwords(self):
        """Load passwords from storage."""
        try:
            with open(self.storage_path / 'passwords.json', 'r') as f:
                passwords_data = json.load(f)
                
            self._passwords = {
                id_: Password(
                    id=data['id'],
                    domain=data['domain'],
                    username=data['username'],
                    encrypted_password=base64.b64decode(data['encrypted_password']),
                    description=data['description'],
                    created_at=datetime.fromisoformat(data['created_at']),
                    modified_at=datetime.fromisoformat(data['modified_at'])
                )
                for id_, data in passwords_data.items()
            }
        except FileNotFoundError:
            self._passwords = {} from dataclasses import dataclass
from datetime import datetime
from typing import Optional
import uuid

@dataclass
class Password:
    """Represents a stored password entry."""
    id: str
    domain: str
    username: str
    encrypted_password: bytes
    description: Optional[str] = None
    created_at: datetime = datetime.now()
    modified_at: datetime = datetime.now()
    
    @classmethod
    def create(cls, domain: str, username: str, encrypted_password: bytes, description: Optional[str] = None) -> 'Password':
        """Create a new password entry."""
        return cls(
            id=str(uuid.uuid4()),
            domain=domain,
            username=username,
            encrypted_password=encrypted_password,
            description=description
        ) # password_manager/cli/session.py

from datetime import datetime, timedelta

class Session:
    """Manages user authentication session."""
    
    def __init__(self, timeout_minutes: int = 30):
        self.timeout_minutes = timeout_minutes
        self.last_activity = None
        self.is_authenticated = False
    
    def login(self):
        self.last_activity = datetime.now()
        self.is_authenticated = True
    
    def logout(self):
        self.last_activity = None
        self.is_authenticated = False
    
    def is_valid(self):
        """Check if the session is still within the allowed timeout."""
        if not self.is_authenticated or not self.last_activity:
            return False
        return (datetime.now() - self.last_activity) < timedelta(minutes=self.timeout_minutes)
    
    def refresh(self):
        """Refresh the session's last activity timestamp."""
        if self.is_authenticated:
            self.last_activity = datetime.now()

# Global session instance with a 30-minute timeout
current_session = Session(timeout_minutes=30)
# password_manager/cli/commands.py

import click
import os
import json
import base64
import logging
from pathlib import Path
from datetime import datetime, timedelta
from functools import wraps
from password_manager.core.auth import HashBasedAuth
from password_manager.core.encryption import AES256Encryption
from password_manager.core.vault import PasswordVault
from password_manager.cli.session import current_session

# Set the data directory to a subdirectory in the user's home directory
DATA_DIR = Path(os.path.expanduser('~/.password_manager_data'))
MASTER_PASSWORD_FILE = DATA_DIR / 'master.key'

# Initialize auth service
auth_service = HashBasedAuth(MASTER_PASSWORD_FILE)

# Global variables for the encryption service and vault;
# they will be initialized upon successful authentication.
encryption_service = None
vault = None

def initialize_services(master_key: bytes):
    """Initialize encryption service and vault using the persisted salt."""
    global encryption_service, vault
    # Reuse the salt from the auth service to ensure consistent key derivation.
    encryption_service = AES256Encryption(master_key=master_key, salt=auth_service.salt)
    vault = PasswordVault(encryption_service, DATA_DIR)

def require_auth(f):
    """Decorator to require authentication before executing a command."""
    @wraps(f)
    def wrapped(*args, **kwargs):
        # Use is_valid() to check if the session has expired
        if not current_session.is_valid():
            password = click.prompt("Enter master password", hide_input=True).strip()
            if auth_service.authenticate(password):
                initialize_services(auth_service.get_master_key())
                current_session.login()  # sets last_activity and is_authenticated
            else:
                click.echo("Authentication failed.")
                return
        else:
            # If session is valid, refresh the last_activity to extend the timeout
            current_session.refresh()
        return f(*args, **kwargs)
    return wrapped


@click.group()
def cli():
    """Password Manager CLI

    This tool allows you to securely manage your passwords.
    Use the commands below to add, search, and manage your passwords.
    """
    pass

@cli.command()
def set_master_password():
    """Set or update the master password for authentication."""
    password = click.prompt('Enter new master password', hide_input=True, confirmation_prompt=True).strip()
    auth_service.set_master_password(password)
    initialize_services(auth_service.get_master_key())
    click.echo("Master password set successfully.")

@cli.command()
def authenticate():
    """Authenticate with the master password."""
    password = click.prompt("Enter master password", hide_input=True).strip()
    if auth_service.authenticate(password):
        initialize_services(auth_service.get_master_key())
        current_session.login()  # This resets the session timeout
        click.echo("Authentication successful.")
    else:
        click.echo("Authentication failed.")

@cli.command()
@require_auth
def add_password():
    """Add a new password to the vault."""
    domain = click.prompt('Domain')
    username = click.prompt('Username')
    password = click.prompt('Password', hide_input=True).strip()
    description = click.prompt('Description', default='', show_default=False)
    password_entry = vault.add_password(domain, username, password, description)
    click.echo(f"Password for {domain} added successfully with ID: {password_entry.id}")

@cli.command()
@require_auth
def list():
    """List all stored passwords with their details."""
    passwords = vault.list_passwords()
    if not passwords:
        click.echo("No passwords stored.")
        return
    for pwd in passwords:
        click.echo(f"\nDomain: {pwd.domain}")
        click.echo(f"Username: {pwd.username}")
        click.echo(f"Description: {pwd.description}")
        click.echo(f"ID: {pwd.id}")

@cli.command()
@require_auth
def show():
    """Show details of a specific password by domain or username."""
    query = click.prompt('Enter domain or username to search')
    matching_passwords = [
        pwd for pwd in vault.list_passwords()
        if query.lower() in pwd.domain.lower() or query.lower() in pwd.username.lower()
    ]
    
    if not matching_passwords:
        click.echo("No matching passwords found.")
        return
    
    if len(matching_passwords) == 1:
        selected_password = matching_passwords[0]
    else:
        click.echo("Multiple matches found:")
        for i, pwd in enumerate(matching_passwords, start=1):
            click.echo(f"{i}: Domain: {pwd.domain}, Username: {pwd.username}")
        choice = click.prompt("Select a password by number", type=int)
        if choice < 1 or choice > len(matching_passwords):
            click.echo("Invalid selection.")
            return
        selected_password = matching_passwords[choice - 1]
    
    click.echo(f"\nDomain: {selected_password.domain}")
    click.echo(f"Username: {selected_password.username}")
    click.echo(f"Description: {selected_password.description}")
    
    if click.confirm("Show password?"):
        try:
            decrypted = vault.get_decrypted_password(selected_password.id)
            click.echo(f"Password: {decrypted}")
        except Exception as e:
            click.echo("Failed to decrypt password.")

@cli.command()
@require_auth
def delete():
    """Delete a password from the vault by ID."""
    pwd_id = click.prompt('Password ID')
    if vault.delete_password(pwd_id):
        click.echo("Password deleted successfully!")
    else:
        click.echo("Password not found.")

@cli.command()
def install_completion():
    """Install shell completion for the vault command."""
    click.echo("To enable shell completion, add the following line to your shell's configuration file:")
    click.echo('eval "$(_VAULT_COMPLETE=source_bash vault)"')

def main():
    """Main entry point."""
    DATA_DIR.mkdir(parents=True, exist_ok=True)
    cli()

if __name__ == '__main__':
    main()
